<!DOCTYPE html><html lang="en"><head>
    <base href="http://kangax.github.io/nfe/">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta content="An article about named function expressions in Javascript" name="description">
    <meta content="named function expressions, function expression, javascript, jscript identifier leak, function names in debuggers" name="keywords">
    <meta content="Juriy 'kangax' Zaytsev" name="author">
    <title>Named function expressions demystified</title>
    <style data-savepage-href="all.css">

/*! * Bootstrap v3.2.0 (http://getbootstrap.com) * Copyright 2011-2014 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) *//*! * Generated using the Bootstrap Customizer (http://getbootstrap.com/customize/?id=c3f912832d5ecfdcfb0c) * Config saved to config.json and https://gist.github.com/c3f912832d5ecfdcfb0c *//*! normalize.css v3.0.1 | MIT License | git.io/normalize */html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}h1{font-size:2em;margin:0.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace, monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}input[type="number"]::-webkit-inner-spin-button,input[type="number"]::-webkit-outer-spin-button{height:auto}input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid #c0c0c0;margin:0 2px;padding:0.35em 0.625em 0.75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:bold}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}@media print{*{text-shadow:none !important;color:#000 !important;background:transparent !important;box-shadow:none !important}a,a:visited{text-decoration:underline}a[href]:after{content:" (" attr(href) ")"}abbr[title]:after{content:" (" attr(title) ")"}a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}p,h2,h3{orphans:3;widows:3}h2,h3{page-break-after:avoid}select{background:#fff !important}.navbar{display:none}.table td,.table th{background-color:#fff !important}.btn>.caret,.dropup>.btn>.caret{border-top-color:#000 !important}.label{border:1px solid #000}.table{border-collapse:collapse !important}.table-bordered th,.table-bordered td{border:1px solid #ddd !important}}*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}*:before,*:after{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}html{font-size:10px;-webkit-tap-highlight-color:rgba(0,0,0,0)}body{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:14px;line-height:1.42857143;color:#333;background-color:#fff}input,button,select,textarea{font-family:inherit;font-size:inherit;line-height:inherit}a{color:#428bca;text-decoration:none}a:hover,a:focus{color:#2a6496;text-decoration:underline}a:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}figure{margin:0}img{vertical-align:middle}.img-responsive{display:block;width:100% \9;max-width:100%;height:auto}.img-rounded{border-radius:6px}.img-thumbnail{padding:4px;line-height:1.42857143;background-color:#fff;border:1px solid #ddd;border-radius:4px;-webkit-transition:all .2s ease-in-out;-o-transition:all .2s ease-in-out;transition:all .2s ease-in-out;display:inline-block;width:100% \9;max-width:100%;height:auto}.img-circle{border-radius:50%}hr{margin-top:20px;margin-bottom:20px;border:0;border-top:1px solid #eee}.sr-only{position:absolute;width:1px;height:1px;margin:-1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}h1,h2,h3,h4,h5,h6,.h1,.h2,.h3,.h4,.h5,.h6{font-family:inherit;font-weight:500;line-height:1.1;color:inherit}h1 small,h2 small,h3 small,h4 small,h5 small,h6 small,.h1 small,.h2 small,.h3 small,.h4 small,.h5 small,.h6 small,h1 .small,h2 .small,h3 .small,h4 .small,h5 .small,h6 .small,.h1 .small,.h2 .small,.h3 .small,.h4 .small,.h5 .small,.h6 .small{font-weight:normal;line-height:1;color:#777}h1,.h1,h2,.h2,h3,.h3{margin-top:20px;margin-bottom:10px}h1 small,.h1 small,h2 small,.h2 small,h3 small,.h3 small,h1 .small,.h1 .small,h2 .small,.h2 .small,h3 .small,.h3 .small{font-size:65%}h4,.h4,h5,.h5,h6,.h6{margin-top:10px;margin-bottom:10px}h4 small,.h4 small,h5 small,.h5 small,h6 small,.h6 small,h4 .small,.h4 .small,h5 .small,.h5 .small,h6 .small,.h6 .small{font-size:75%}h1,.h1{font-size:36px}h2,.h2{font-size:30px}h3,.h3{font-size:24px}h4,.h4{font-size:18px}h5,.h5{font-size:14px}h6,.h6{font-size:12px}p{margin:0 0 10px}.lead{margin-bottom:20px;font-size:16px;font-weight:300;line-height:1.4}@media (min-width:768px){.lead{font-size:21px}}small,.small{font-size:85%}cite{font-style:normal}mark,.mark{background-color:#fcf8e3;padding:.2em}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}.text-justify{text-align:justify}.text-nowrap{white-space:nowrap}.text-lowercase{text-transform:lowercase}.text-uppercase{text-transform:uppercase}.text-capitalize{text-transform:capitalize}.text-muted{color:#777}.text-primary{color:#428bca}a.text-primary:hover{color:#3071a9}.text-success{color:#3c763d}a.text-success:hover{color:#2b542c}.text-info{color:#31708f}a.text-info:hover{color:#245269}.text-warning{color:#8a6d3b}a.text-warning:hover{color:#66512c}.text-danger{color:#a94442}a.text-danger:hover{color:#843534}.bg-primary{color:#fff;background-color:#428bca}a.bg-primary:hover{background-color:#3071a9}.bg-success{background-color:#dff0d8}a.bg-success:hover{background-color:#c1e2b3}.bg-info{background-color:#d9edf7}a.bg-info:hover{background-color:#afd9ee}.bg-warning{background-color:#fcf8e3}a.bg-warning:hover{background-color:#f7ecb5}.bg-danger{background-color:#f2dede}a.bg-danger:hover{background-color:#e4b9b9}.page-header{padding-bottom:9px;margin:40px 0 20px;border-bottom:1px solid #eee}ul,ol{margin-top:0;margin-bottom:10px}ul ul,ol ul,ul ol,ol ol{margin-bottom:0}.list-unstyled{padding-left:0;list-style:none}.list-inline{padding-left:0;list-style:none;margin-left:-5px}.list-inline>li{display:inline-block;padding-left:5px;padding-right:5px}dl{margin-top:0;margin-bottom:20px}dt,dd{line-height:1.42857143}dt{font-weight:bold}dd{margin-left:0}@media (min-width:768px){.dl-horizontal dt{float:left;width:160px;clear:left;text-align:right;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.dl-horizontal dd{margin-left:180px}}abbr[title],abbr[data-original-title]{cursor:help;border-bottom:1px dotted #777}.initialism{font-size:90%;text-transform:uppercase}blockquote{padding:10px 20px;margin:0 0 20px;font-size:17.5px;border-left:5px solid #eee}blockquote p:last-child,blockquote ul:last-child,blockquote ol:last-child{margin-bottom:0}blockquote footer,blockquote small,blockquote .small{display:block;font-size:80%;line-height:1.42857143;color:#777}blockquote footer:before,blockquote small:before,blockquote .small:before{content:'\2014 \00A0'}.blockquote-reverse,blockquote.pull-right{padding-right:15px;padding-left:0;border-right:5px solid #eee;border-left:0;text-align:right}.blockquote-reverse footer:before,blockquote.pull-right footer:before,.blockquote-reverse small:before,blockquote.pull-right small:before,.blockquote-reverse .small:before,blockquote.pull-right .small:before{content:''}.blockquote-reverse footer:after,blockquote.pull-right footer:after,.blockquote-reverse small:after,blockquote.pull-right small:after,.blockquote-reverse .small:after,blockquote.pull-right .small:after{content:'\00A0 \2014'}blockquote:before,blockquote:after{content:""}address{margin-bottom:20px;font-style:normal;line-height:1.42857143}code,kbd,pre,samp{font-family:Menlo,Monaco,Consolas,"Courier New",monospace}code{padding:2px 4px;font-size:90%;color:#c7254e;background-color:#f9f2f4;border-radius:4px}kbd{padding:2px 4px;font-size:90%;color:#fff;background-color:#333;border-radius:3px;box-shadow:inset 0 -1px 0 rgba(0,0,0,0.25)}kbd kbd{padding:0;font-size:100%;box-shadow:none}pre{display:block;padding:9.5px;margin:0 0 10px;font-size:13px;line-height:1.42857143;word-break:break-all;word-wrap:break-word;color:#333;background-color:#f5f5f5;border:1px solid #ccc;border-radius:4px}pre code{padding:0;font-size:inherit;color:inherit;white-space:pre-wrap;background-color:transparent;border-radius:0}.pre-scrollable{max-height:340px;overflow-y:scroll}.container{margin-right:auto;margin-left:auto;padding-left:15px;padding-right:15px}@media (min-width:768px){.container{width:750px}}@media (min-width:992px){.container{width:970px}}@media (min-width:1200px){.container{width:1170px}}.container-fluid{margin-right:auto;margin-left:auto;padding-left:15px;padding-right:15px}.row{margin-left:-15px;margin-right:-15px}.col-xs-1, .col-sm-1, .col-md-1, .col-lg-1, .col-xs-2, .col-sm-2, .col-md-2, .col-lg-2, .col-xs-3, .col-sm-3, .col-md-3, .col-lg-3, .col-xs-4, .col-sm-4, .col-md-4, .col-lg-4, .col-xs-5, .col-sm-5, .col-md-5, .col-lg-5, .col-xs-6, .col-sm-6, .col-md-6, .col-lg-6, .col-xs-7, .col-sm-7, .col-md-7, .col-lg-7, .col-xs-8, .col-sm-8, .col-md-8, .col-lg-8, .col-xs-9, .col-sm-9, .col-md-9, .col-lg-9, .col-xs-10, .col-sm-10, .col-md-10, .col-lg-10, .col-xs-11, .col-sm-11, .col-md-11, .col-lg-11, .col-xs-12, .col-sm-12, .col-md-12, .col-lg-12{position:relative;min-height:1px;padding-left:15px;padding-right:15px}.col-xs-1, .col-xs-2, .col-xs-3, .col-xs-4, .col-xs-5, .col-xs-6, .col-xs-7, .col-xs-8, .col-xs-9, .col-xs-10, .col-xs-11, .col-xs-12{float:left}.col-xs-12{width:100%}.col-xs-11{width:91.66666667%}.col-xs-10{width:83.33333333%}.col-xs-9{width:75%}.col-xs-8{width:66.66666667%}.col-xs-7{width:58.33333333%}.col-xs-6{width:50%}.col-xs-5{width:41.66666667%}.col-xs-4{width:33.33333333%}.col-xs-3{width:25%}.col-xs-2{width:16.66666667%}.col-xs-1{width:8.33333333%}.col-xs-pull-12{right:100%}.col-xs-pull-11{right:91.66666667%}.col-xs-pull-10{right:83.33333333%}.col-xs-pull-9{right:75%}.col-xs-pull-8{right:66.66666667%}.col-xs-pull-7{right:58.33333333%}.col-xs-pull-6{right:50%}.col-xs-pull-5{right:41.66666667%}.col-xs-pull-4{right:33.33333333%}.col-xs-pull-3{right:25%}.col-xs-pull-2{right:16.66666667%}.col-xs-pull-1{right:8.33333333%}.col-xs-pull-0{right:auto}.col-xs-push-12{left:100%}.col-xs-push-11{left:91.66666667%}.col-xs-push-10{left:83.33333333%}.col-xs-push-9{left:75%}.col-xs-push-8{left:66.66666667%}.col-xs-push-7{left:58.33333333%}.col-xs-push-6{left:50%}.col-xs-push-5{left:41.66666667%}.col-xs-push-4{left:33.33333333%}.col-xs-push-3{left:25%}.col-xs-push-2{left:16.66666667%}.col-xs-push-1{left:8.33333333%}.col-xs-push-0{left:auto}.col-xs-offset-12{margin-left:100%}.col-xs-offset-11{margin-left:91.66666667%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-0{margin-left:0}@media (min-width:768px){.col-sm-1, .col-sm-2, .col-sm-3, .col-sm-4, .col-sm-5, .col-sm-6, .col-sm-7, .col-sm-8, .col-sm-9, .col-sm-10, .col-sm-11, .col-sm-12{float:left}.col-sm-12{width:100%}.col-sm-11{width:91.66666667%}.col-sm-10{width:83.33333333%}.col-sm-9{width:75%}.col-sm-8{width:66.66666667%}.col-sm-7{width:58.33333333%}.col-sm-6{width:50%}.col-sm-5{width:41.66666667%}.col-sm-4{width:33.33333333%}.col-sm-3{width:25%}.col-sm-2{width:16.66666667%}.col-sm-1{width:8.33333333%}.col-sm-pull-12{right:100%}.col-sm-pull-11{right:91.66666667%}.col-sm-pull-10{right:83.33333333%}.col-sm-pull-9{right:75%}.col-sm-pull-8{right:66.66666667%}.col-sm-pull-7{right:58.33333333%}.col-sm-pull-6{right:50%}.col-sm-pull-5{right:41.66666667%}.col-sm-pull-4{right:33.33333333%}.col-sm-pull-3{right:25%}.col-sm-pull-2{right:16.66666667%}.col-sm-pull-1{right:8.33333333%}.col-sm-pull-0{right:auto}.col-sm-push-12{left:100%}.col-sm-push-11{left:91.66666667%}.col-sm-push-10{left:83.33333333%}.col-sm-push-9{left:75%}.col-sm-push-8{left:66.66666667%}.col-sm-push-7{left:58.33333333%}.col-sm-push-6{left:50%}.col-sm-push-5{left:41.66666667%}.col-sm-push-4{left:33.33333333%}.col-sm-push-3{left:25%}.col-sm-push-2{left:16.66666667%}.col-sm-push-1{left:8.33333333%}.col-sm-push-0{left:auto}.col-sm-offset-12{margin-left:100%}.col-sm-offset-11{margin-left:91.66666667%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-0{margin-left:0}}@media (min-width:992px){.col-md-1, .col-md-2, .col-md-3, .col-md-4, .col-md-5, .col-md-6, .col-md-7, .col-md-8, .col-md-9, .col-md-10, .col-md-11, .col-md-12{float:left}.col-md-12{width:100%}.col-md-11{width:91.66666667%}.col-md-10{width:83.33333333%}.col-md-9{width:75%}.col-md-8{width:66.66666667%}.col-md-7{width:58.33333333%}.col-md-6{width:50%}.col-md-5{width:41.66666667%}.col-md-4{width:33.33333333%}.col-md-3{width:25%}.col-md-2{width:16.66666667%}.col-md-1{width:8.33333333%}.col-md-pull-12{right:100%}.col-md-pull-11{right:91.66666667%}.col-md-pull-10{right:83.33333333%}.col-md-pull-9{right:75%}.col-md-pull-8{right:66.66666667%}.col-md-pull-7{right:58.33333333%}.col-md-pull-6{right:50%}.col-md-pull-5{right:41.66666667%}.col-md-pull-4{right:33.33333333%}.col-md-pull-3{right:25%}.col-md-pull-2{right:16.66666667%}.col-md-pull-1{right:8.33333333%}.col-md-pull-0{right:auto}.col-md-push-12{left:100%}.col-md-push-11{left:91.66666667%}.col-md-push-10{left:83.33333333%}.col-md-push-9{left:75%}.col-md-push-8{left:66.66666667%}.col-md-push-7{left:58.33333333%}.col-md-push-6{left:50%}.col-md-push-5{left:41.66666667%}.col-md-push-4{left:33.33333333%}.col-md-push-3{left:25%}.col-md-push-2{left:16.66666667%}.col-md-push-1{left:8.33333333%}.col-md-push-0{left:auto}.col-md-offset-12{margin-left:100%}.col-md-offset-11{margin-left:91.66666667%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-9{margin-left:75%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-6{margin-left:50%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-3{margin-left:25%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-0{margin-left:0}}@media (min-width:1200px){.col-lg-1, .col-lg-2, .col-lg-3, .col-lg-4, .col-lg-5, .col-lg-6, .col-lg-7, .col-lg-8, .col-lg-9, .col-lg-10, .col-lg-11, .col-lg-12{float:left}.col-lg-12{width:100%}.col-lg-11{width:91.66666667%}.col-lg-10{width:83.33333333%}.col-lg-9{width:75%}.col-lg-8{width:66.66666667%}.col-lg-7{width:58.33333333%}.col-lg-6{width:50%}.col-lg-5{width:41.66666667%}.col-lg-4{width:33.33333333%}.col-lg-3{width:25%}.col-lg-2{width:16.66666667%}.col-lg-1{width:8.33333333%}.col-lg-pull-12{right:100%}.col-lg-pull-11{right:91.66666667%}.col-lg-pull-10{right:83.33333333%}.col-lg-pull-9{right:75%}.col-lg-pull-8{right:66.66666667%}.col-lg-pull-7{right:58.33333333%}.col-lg-pull-6{right:50%}.col-lg-pull-5{right:41.66666667%}.col-lg-pull-4{right:33.33333333%}.col-lg-pull-3{right:25%}.col-lg-pull-2{right:16.66666667%}.col-lg-pull-1{right:8.33333333%}.col-lg-pull-0{right:auto}.col-lg-push-12{left:100%}.col-lg-push-11{left:91.66666667%}.col-lg-push-10{left:83.33333333%}.col-lg-push-9{left:75%}.col-lg-push-8{left:66.66666667%}.col-lg-push-7{left:58.33333333%}.col-lg-push-6{left:50%}.col-lg-push-5{left:41.66666667%}.col-lg-push-4{left:33.33333333%}.col-lg-push-3{left:25%}.col-lg-push-2{left:16.66666667%}.col-lg-push-1{left:8.33333333%}.col-lg-push-0{left:auto}.col-lg-offset-12{margin-left:100%}.col-lg-offset-11{margin-left:91.66666667%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-0{margin-left:0}}.well{min-height:20px;padding:19px;margin-bottom:20px;background-color:#f5f5f5;border:1px solid #e3e3e3;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.05);box-shadow:inset 0 1px 1px rgba(0,0,0,0.05)}.well blockquote{border-color:#ddd;border-color:rgba(0,0,0,0.15)}.well-lg{padding:24px;border-radius:6px}.well-sm{padding:9px;border-radius:3px}.clearfix:before,.clearfix:after,.dl-horizontal dd:before,.dl-horizontal dd:after,.container:before,.container:after,.container-fluid:before,.container-fluid:after,.row:before,.row:after{content:" ";display:table}.clearfix:after,.dl-horizontal dd:after,.container:after,.container-fluid:after,.row:after{clear:both}.center-block{display:block;margin-left:auto;margin-right:auto}.pull-right{float:right !important}.pull-left{float:left !important}.hide{display:none !important}.show{display:block !important}.invisible{visibility:hidden}.text-hide{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.hidden{display:none !important;visibility:hidden !important}.affix{position:fixed;-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0)}@-ms-viewport{width:device-width}.visible-xs,.visible-sm,.visible-md,.visible-lg{display:none !important}.visible-xs-block,.visible-xs-inline,.visible-xs-inline-block,.visible-sm-block,.visible-sm-inline,.visible-sm-inline-block,.visible-md-block,.visible-md-inline,.visible-md-inline-block,.visible-lg-block,.visible-lg-inline,.visible-lg-inline-block{display:none !important}@media (max-width:767px){.visible-xs{display:block !important}table.visible-xs{display:table}tr.visible-xs{display:table-row !important}th.visible-xs,td.visible-xs{display:table-cell !important}}@media (max-width:767px){.visible-xs-block{display:block !important}}@media (max-width:767px){.visible-xs-inline{display:inline !important}}@media (max-width:767px){.visible-xs-inline-block{display:inline-block !important}}@media (min-width:768px) and (max-width:991px){.visible-sm{display:block !important}table.visible-sm{display:table}tr.visible-sm{display:table-row !important}th.visible-sm,td.visible-sm{display:table-cell !important}}@media (min-width:768px) and (max-width:991px){.visible-sm-block{display:block !important}}@media (min-width:768px) and (max-width:991px){.visible-sm-inline{display:inline !important}}@media (min-width:768px) and (max-width:991px){.visible-sm-inline-block{display:inline-block !important}}@media (min-width:992px) and (max-width:1199px){.visible-md{display:block !important}table.visible-md{display:table}tr.visible-md{display:table-row !important}th.visible-md,td.visible-md{display:table-cell !important}}@media (min-width:992px) and (max-width:1199px){.visible-md-block{display:block !important}}@media (min-width:992px) and (max-width:1199px){.visible-md-inline{display:inline !important}}@media (min-width:992px) and (max-width:1199px){.visible-md-inline-block{display:inline-block !important}}@media (min-width:1200px){.visible-lg{display:block !important}table.visible-lg{display:table}tr.visible-lg{display:table-row !important}th.visible-lg,td.visible-lg{display:table-cell !important}}@media (min-width:1200px){.visible-lg-block{display:block !important}}@media (min-width:1200px){.visible-lg-inline{display:inline !important}}@media (min-width:1200px){.visible-lg-inline-block{display:inline-block !important}}@media (max-width:767px){.hidden-xs{display:none !important}}@media (min-width:768px) and (max-width:991px){.hidden-sm{display:none !important}}@media (min-width:992px) and (max-width:1199px){.hidden-md{display:none !important}}@media (min-width:1200px){.hidden-lg{display:none !important}}.visible-print{display:none !important}@media print{.visible-print{display:block !important}table.visible-print{display:table}tr.visible-print{display:table-row !important}th.visible-print,td.visible-print{display:table-cell !important}}.visible-print-block{display:none !important}@media print{.visible-print-block{display:block !important}}.visible-print-inline{display:none !important}@media print{.visible-print-inline{display:inline !important}}.visible-print-inline-block{display:none !important}@media print{.visible-print-inline-block{display:inline-block !important}}@media print{.hidden-print{display:none !important}}.hll { background-color: #ffffcc } /*{ background: #f0f3f3; }*/.c { color: #999; } /* Comment */.err { color: #AA0000; background-color: #FFAAAA } /* Error */.k { color: #006699; } /* Keyword */.o { color: #555555 } /* Operator */.cm { color: #999; } /* Comment.Multiline */ /* Edited to remove italics and make into comment */.cp { color: #009999 } /* Comment.Preproc */.c1 { color: #999; } /* Comment.Single */.cs { color: #999; } /* Comment.Special */.gd { background-color: #FFCCCC; border: 1px solid #CC0000 } /* Generic.Deleted */.ge { font-style: italic } /* Generic.Emph */.gr { color: #FF0000 } /* Generic.Error */.gh { color: #003300; } /* Generic.Heading */.gi { background-color: #CCFFCC; border: 1px solid #00CC00 } /* Generic.Inserted */.go { color: #AAAAAA } /* Generic.Output */.gp { color: #000099; } /* Generic.Prompt */.gs { } /* Generic.Strong */.gu { color: #003300; } /* Generic.Subheading */.gt { color: #99CC66 } /* Generic.Traceback */.kc { color: #006699; } /* Keyword.Constant */.kd { color: #006699; } /* Keyword.Declaration */.kn { color: #006699; } /* Keyword.Namespace */.kp { color: #006699 } /* Keyword.Pseudo */.kr { color: #006699; } /* Keyword.Reserved */.kt { color: #007788; } /* Keyword.Type */.m { color: #FF6600 } /* Literal.Number */.s { color: #d44950 } /* Literal.String */.na { color: #4f9fcf } /* Name.Attribute */.nb { color: #336666 } /* Name.Builtin */.nc { color: #00AA88; } /* Name.Class */.no { color: #336600 } /* Name.Constant */.nd { color: #9999FF } /* Name.Decorator */.ni { color: #999999; } /* Name.Entity */.ne { color: #CC0000; } /* Name.Exception */.nf { color: #CC00FF } /* Name.Function */.nl { color: #9999FF } /* Name.Label */.nn { color: #00CCFF; } /* Name.Namespace */.nt { color: #2f6f9f; } /* Name.Tag */.nv { color: #003333 } /* Name.Variable */.ow { color: #000000; } /* Operator.Word */.w { color: #bbbbbb } /* Text.Whitespace */.mf { color: #FF6600 } /* Literal.Number.Float */.mh { color: #FF6600 } /* Literal.Number.Hex */.mi { color: #FF6600 } /* Literal.Number.Integer */.mo { color: #FF6600 } /* Literal.Number.Oct */.sb { color: #CC3300 } /* Literal.String.Backtick */.sc { color: #CC3300 } /* Literal.String.Char */.sd { color: #CC3300; font-style: italic } /* Literal.String.Doc */.s2 { color: #CC3300 } /* Literal.String.Double */.se { color: #CC3300; } /* Literal.String.Escape */.sh { color: #CC3300 } /* Literal.String.Heredoc */.si { color: #AA0000 } /* Literal.String.Interpol */.sx { color: #CC3300 } /* Literal.String.Other */.sr { color: #33AAAA } /* Literal.String.Regex */.s1 { color: #CC3300 } /* Literal.String.Single */.ss { color: #FFCC33 } /* Literal.String.Symbol */.bp { color: #336666 } /* Name.Builtin.Pseudo */.vc { color: #003333 } /* Name.Variable.Class */.vg { color: #003333 } /* Name.Variable.Global */.vi { color: #003333 } /* Name.Variable.Instance */.il { color: #FF6600 } /* Literal.Number.Integer.Long */.css .o,.css .o + .nt,.css .nt + .nt { color: #999; }h1 .small {display: inline-block;line-height: 1.8;}.well.bg-success {background-color: #dfd;}.highlight pre {padding: 15px;overflow-x: auto;word-wrap: normal;white-space: pre;}pre code {overflow-x: auto;word-wrap: normal;white-space: pre;}.footer {margin-top: 2em;margin-bottom: 1em;}@media (min-width: 992px) {h1 .small,.footer-right { float: right;}}
</style>
    <!--[if lt IE 9]>
      <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
  <script type="text/javascript" async="" data-savepage-src="http://www.google-analytics.com/ga.js" src=""></script><style id="style-1-cropbar-clipper">/* Copyright 2014 Evernote Corporation. All rights reserved. */
.en-markup-crop-options {
    top: 18px !important;
    left: 50% !important;
    margin-left: -100px !important;
    width: 200px !important;
    border: 2px rgba(255,255,255,.38) solid !important;
    border-radius: 4px !important;
}

.en-markup-crop-options div div:first-of-type {
    margin-left: 0px !important;
}
</style>
    <link rel="icon" href="">
    <script id="savepage-contentloaders" type="application/javascript">
      "use strict"
      savepage_ContentLoaders();
      function savepage_ContentLoaders()
      {
        var resourceMimeType = new Array();
        var resourceBase64Data = new Array();
        var resourceBlobUrl = new Array();
        window.addEventListener("DOMContentLoaded",
        function(event)
        {
          savepage_ShadowLoader(5);
          savepage_ResourceLoader(5);
          document.getElementById('savepage-contentloaders').remove();
        },false);
        function savepage_ShadowLoader(c){createShadowDOMs(0,document.documentElement);function createShadowDOMs(a,b){var i;if(b.localName=="iframe"||b.localName=="frame"){if(a<c){try{if(b.contentDocument.documentElement!=null){createShadowDOMs(a+1,b.contentDocument.documentElement)}}catch(e){}}}else{if(b.children.length>=1&&b.children[0].localName=="template"&&b.children[0].hasAttribute("data-savepage-shadowroot")){b.attachShadow({mode:"open"}).appendChild(b.children[0].content);b.removeChild(b.children[0]);for(i=0;i<b.shadowRoot.children.length;i++)if(b.shadowRoot.children[i]!=null)createShadowDOMs(a,b.shadowRoot.children[i])}for(i=0;i<b.children.length;i++)if(b.children[i]!=null)createShadowDOMs(a,b.children[i])}}}
        function savepage_ResourceLoader(f){createBlobURLs();replaceReferences(0,document.documentElement);function createBlobURLs(){var i,j,binaryString,blobData;var a=new Array();for(i=0;i<resourceMimeType.length;i++){if(typeof resourceMimeType[i]!="undefined"){binaryString=atob(resourceBase64Data[i]);resourceBase64Data[i]="";a.length=0;for(j=0;j<binaryString.length;j++){a[j]=binaryString.charCodeAt(j)}blobData=new Blob([new Uint8Array(a)],{type:resourceMimeType[i]});resourceMimeType[i]="";resourceBlobUrl[i]=window.URL.createObjectURL(blobData)}}}function replaceReferences(a,b){var i,regex1,regex2,csstext,blobData;regex1=/url\(\s*((?:"[^"]+")|(?:'[^']+')|(?:[^\s)]+))\s*\)/gi;regex2=/data:[^;]*;resource=(\d+);base64,/i;if(b.hasAttribute("style")){csstext=b.style.cssText;b.style.cssText=csstext.replace(regex1,replaceCSSRef)}if(b.localName=="style"){csstext=b.textContent;b.textContent=csstext.replace(regex1,replaceCSSRef)}else if(b.localName=="link"&&(b.rel.toLowerCase()=="icon"||b.rel.toLowerCase()=="shortcut icon")){if(b.href!="")b.href=b.href.replace(regex2,replaceRef)}else if(b.localName=="body"){if(b.background!="")b.background=b.background.replace(regex2,replaceRef)}else if(b.localName=="img"){if(b.src!="")b.src=b.src.replace(regex2,replaceRef)}else if(b.localName=="input"&&b.type.toLowerCase()=="image"){if(b.src!="")b.src=b.src.replace(regex2,replaceRef)}else if(b.localName=="audio"){if(b.src!=""){b.src=b.src.replace(regex2,replaceRef);b.load()}}else if(b.localName=="video"){if(b.src!=""){b.src=b.src.replace(regex2,replaceRef);b.load()}if(b.poster!="")b.poster=b.poster.replace(regex2,replaceRef)}else if(b.localName=="source"){if(b.src!=""){b.src=b.src.replace(regex2,replaceRef);b.parentElement.load()}}else if(b.localName=="track"){if(b.src!="")b.src=b.src.replace(regex2,replaceRef)}else if(b.localName=="object"){if(b.data!="")b.data=b.data.replace(regex2,replaceRef)}else if(b.localName=="embed"){if(b.src!="")b.src=b.src.replace(regex2,replaceRef)}if(b.localName=="iframe"||b.localName=="frame"){if(a<f){if(b.hasAttribute("data-savepage-sameorigin")){blobData=new Blob([decodeURIComponent(b.src.substr(29))],{type:"text/html;charset=utf-8"});b.onload=function(){try{if(b.contentDocument.documentElement!=null){replaceReferences(a+1,b.contentDocument.documentElement)}}catch(e){}};b.src=window.URL.createObjectURL(blobData)}}}else{if(b.shadowRoot!=null){for(i=0;i<b.shadowRoot.children.length;i++)if(b.shadowRoot.children[i]!=null)replaceReferences(a,b.shadowRoot.children[i])}for(i=0;i<b.children.length;i++)if(b.children[i]!=null)replaceReferences(a,b.children[i])}}function replaceCSSRef(a,b,c,d){var e=new Array();e=b.match(/data:[^;]*;resource=(\d+);base64,/i);if(e!=null)return"url("+resourceBlobUrl[+e[1]]+")";else return a}function replaceRef(a,b,c,d){return resourceBlobUrl[+b]}}
      }
    </script>
    <meta name="savepage-url" content="http://kangax.github.io/nfe/">
    <meta name="savepage-title" content="Named function expressions demystified">
    <meta name="savepage-date" content="Wed Jun 19 2019 16:54:42 GMT+0800 (中国标准时间)">
    <meta name="savepage-state" content="Standard Items; Used resource loader; Retained cross-origin frames; Removed unsaved URLs; Max frame depth = 5; Max resource size = 50MB; Max resource time = 10s;">
    <meta name="savepage-version" content="15.0">
    <meta name="savepage-comments" content="">
    <meta name="savepage-resourceloader" content=""></head>
  <body>
    <div class="container">

      <div class="page-header">
        <h1>Named function expressions demystified
          <span class="small"><em>by <a href="http://perfectionkills.com/">Juriy "kangax" Zaytsev</a></em></span>
        </h1>
      </div>

      <ol>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#expr-vs-decl">Function expressions vs. Function declarations</a></li>
        <li><a href="#function-statements">Function Statements</a></li>
        <li><a href="#named-expr">Named function expressions</a></li>
        <li><a href="#names-in-debuggers">Function names in debuggers</a></li>
        <li><a href="#jscript-bugs">JScript bugs</a></li>
        <li><a href="#jscript-memory-management">JScript memory management</a></li>
        <li><a href="#tests">Tests</a></li>
        <li><a href="#safari-bug">Safari bug</a></li>
        <li><a href="#spidermonkey-peculiarity">SpiderMonkey peculiarity</a></li>
        <li><a href="#solution">Solution</a></li>
        <li><a href="#alt-solution">Alternative solution</a></li>
        <li><a href="#webkit-displayName">WebKit's displayName</a></li>
        <li><a href="#future-considerations">Future considerations</a></li>
        <li><a href="#credits">Credits</a></li>
      </ol>

      <h2 id="introduction">Introduction</h2>

      <p>Surprisingly, a topic of named function expressions doesn’t seem to be covered well enough on the web. This is probably why there are so many misconceptions floating around. In this article, I’ll try to summarize both — theoretical and practical aspects of these wonderful Javascript constructs; the good, bad and ugly parts of them.</p>

      <p>In a nutshell, named function expressions are useful for one thing only — <strong>descriptive function names in debuggers and profilers</strong>. Well, there is also a possibility of using function names for recursion, but you will soon see that this is often impractical nowadays. If you don’t care about debugging experience, you have nothing to worry about. Otherwise, read on to see some of the cross-browser glitches you would have to deal with and tips on how work around them.</p>

      <p>I’ll start with a general explanation of what function expressions are how modern debuggers handle them. Feel free to skip to a <a href="#solution">final solution</a>, which explains how to use these constructs safely.</p>

      <h2 id="expr-vs-decl">Function expressions vs. Function declarations</h2>

      <p>One of the two most common ways to create a function object in ECMAScript is by means of either <em>Function Expression</em> or <em>Function Declaration</em>. The difference between two is <strong>rather confusing</strong>. At least it was to me. The only thing ECMA specs make clear is that <em>Function Declaration</em> must always have an <em>Identifier</em> (or a function name, if you prefer), and <em>Function Expression</em> may omit it:</p>

      <blockquote>
        <p>FunctionDeclaration :<br>
        function Identifier ( FormalParameterList <sub>opt</sub> ){ FunctionBody }</p>

        <p>FunctionExpression :<br>

        function Identifier <sub>opt</sub> ( FormalParameterList <sub>opt</sub> ){ FunctionBody }</p>
      </blockquote>

      <p>We can see that when identifier is omitted, that “something” can only be an expression. But what if identifier is present? How can one tell whether it is a function declaration or a function expression — they look identical after all? It appears that ECMAScript differentiates between two based on a context. If a <code>function foo(){}</code> is part of, say, assignment expression, it is considered a function expression. If, on the other hand, <code>function foo(){}</code> is contained in a function body or in a (top level of) program itself — it is parsed as a function declaration.</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">foo</span><span class="p">(){}</span> <span class="c1">// declaration, since it's part of a &lt;em&gt;Program&lt;/em&gt;</span>
<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">(){};</span> <span class="c1">// expression, since it's part of an &lt;em&gt;AssignmentExpression&lt;/em&gt;</span>

<span class="k">new</span> <span class="kd">function</span> <span class="nx">bar</span><span class="p">(){};</span> <span class="c1">// expression, since it's part of a &lt;em&gt;NewExpression&lt;/em&gt;</span>

<span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="kd">function</span> <span class="nx">bar</span><span class="p">(){}</span> <span class="c1">// declaration, since it's part of a &lt;em&gt;FunctionBody&lt;/em&gt;</span>
<span class="p">})();</span></code></pre></div>

<p>A somewhat less obvious example of function expression is the one where function is wrapped with parenthesis — <code>(function foo(){})</code>. The reason it is an expression is again due to a context: "(" and ")" constitute a grouping operator and grouping operator can only contain an expression:</p>

<p>To demonstrate with examples:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">foo</span><span class="p">(){}</span> <span class="c1">// function declaration</span>
<span class="p">(</span><span class="kd">function</span> <span class="nx">foo</span><span class="p">(){});</span> <span class="c1">// function expression: due to grouping operator</span>

<span class="k">try</span> <span class="p">{</span>
  <span class="p">(</span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// grouping operator can only contain expression, not a statement (which `var` is)</span>
<span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// SyntaxError</span>
<span class="p">}</span></code></pre></div>

<p>You might also recall that when evaluating JSON with <code>eval</code>, the string is usually wrapped with parenthesis — <code>eval('(' + json + ')')</code>. This is of course done for the same reason — grouping operator, which parenthesis are, forces JSON brackets to be parsed as expression rather than as a block:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="k">try</span> <span class="p">{</span>
  <span class="p">{</span> <span class="s2">"x"</span><span class="o">:</span> <span class="mi">5</span> <span class="p">};</span> <span class="c1">// "{" and "}" are parsed as a block</span>
<span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// SyntaxError</span>
<span class="p">}</span>

<span class="p">({</span> <span class="s2">"x"</span><span class="o">:</span> <span class="mi">5</span> <span class="p">});</span> <span class="c1">// grouping operator forces "{" and "}" to be parsed as object literal</span></code></pre></div>

      <p>There’s a subtle difference in behavior of declarations and expressions.</p>

      <p>First of all, function declarations are parsed and evaluated before any other expressions are. Even if declaration is positioned last in a source, it will be evaluated <strong>foremost any other expressions</strong> contained in a scope. The following example demonstrates how <code>fn</code> function is already defined by the time <code>alert</code> is executed, even though it’s being declared right after it:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">alert</span><span class="p">(</span><span class="nx">fn</span><span class="p">());</span>

<span class="kd">function</span> <span class="nx">fn</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s1">'Hello world!'</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

      <p>Another important trait of function declarations is that declaring them conditionally is non-standardized and varies across different environments. You should never rely on functions being declared conditionally and use function expressions instead.</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// Never do this!</span>
<span class="c1">// Some browsers will declare `foo` as the one returning 'first',</span>
<span class="c1">// while others — returning 'second'</span>

<span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">'first'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">'second'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">();</span>

<span class="c1">// Instead, use function expressions:</span>
<span class="kd">var</span> <span class="nx">foo</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">'first'</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">'second'</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">();</span></code></pre></div>

      <p>If you're curious about actual production rules of function declarations, read on. Otherwise, feel free to skip the following excerpt.</p>

      <div id="function-declarations-in-blocks" class="well bg-success">
        <p>
          <em>FunctionDeclaration</em>s are only allowed to appear in <em>Program</em> or <em>FunctionBody</em>.
          Syntactically, they <strong>can not appear in <em>Block</em></strong> (<code>{ ... }</code>) — such as that of <code>if</code>,
          <code>while</code> or <code>for</code> statements. This is because <em>Block</em>s can only contain <em>Statement</em>s,
          not <em>SourceElement</em>s, which <em>FunctionDeclaration</em> is.
          If we look at production rules carefully, we can see that the only way <em>Expression</em> is allowed directly within <em>Block</em>
          is when it is part of <em>ExpressionStatement</em>. However, <em>ExpressionStatement</em> is explicitly defined
          <strong>to not begin with "function" keyword</strong>, and this is exactly why <em>FunctionDeclaration</em> cannot appear directly within a <em>Statement</em> or <em>Block</em> (note that <em>Block</em> is merely a list of <em>Statement</em>s).
        </p>
        <p>
          Because of these restrictions, whenever function appears directly in a block (such as in the previous example) it should actually be
          <strong>considered a syntax error</strong>, not function declaration or expression. The problem is that almost none of the
          implementations I've seen parse these functions strictly per rules (exceptions are <a href="http://sourceforge.net/projects/besen/">BESEN</a> and <a href="http://www.digitalmars.com/dscript/">DMDScript</a>). They interpret them in proprietary ways instead.
        </p>
      </div>

      <p>It's worth mentioning that as per specification, implementations are allowed to introduce <strong>syntax extensions</strong> (see section 16), yet still be fully conforming. This is exactly what happens in so many clients these days. Some of them interpret function declarations in blocks as any other function declarations — simply hoisting them to the top of the enclosing scope; Others — introduce different semantics and follow slightly more complex rules.</p>

      <h2 id="function-statements">Function statements</h2>

      <div>
        <p>
          One of such syntax extensions to ECMAScript is <strong>Function Statements</strong>,
          currently implemented in Gecko-based browsers (tested in Firefox 1-3.7a1pre on Mac OS X).
          Somehow, this extension doesn't seem to be widely known, either for good or bad (<a href="https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference:Functions#Conditionally_defining_a_function">MDC mentions them</a>, but very briefly).
          Please remember, that we are discussing it here only for learning purposes and to satisfy our curiosity;
          unless you're writing scripts for specific Gecko-based environment,
          <strong>I do not recommend relying on this extension</strong>.
        </p>

        <p>
          So, here are some of the traits of these non-standard constructs:
        </p>

        <ol>
          <li>Function statements are allowed to be anywhere where plain <em>Statement</em>s are allowed. This, of course, includes <em>Block</em>s:
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">f</span><span class="p">(){</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">f</span><span class="p">(){</span> <span class="p">}</span>
<span class="p">}</span></code></pre></div>
        </li>
          <li>Function statements are interpreted as any other statements, including conditional execution:
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">();</span> <span class="c1">// 1</span>
<span class="c1">// Note that other clients interpet `foo` as function declaration here,</span>
<span class="c1">// overwriting first `foo` with the second one, and producing "2", not "1" as a result</span></code></pre></div>
        </li>
        <li>
          Function statements are NOT declared during variable instantiation. They are declared at run time, just like function expressions.
          However, once declared, function statement's identifier <strong>becomes available to the entire scope</strong> of the function.
          This identifier availability is what makes function statements different from function expressions (you will see exact behavior of named function expressions in next chapter).
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// at this point, `foo` is not yet declared</span>
<span class="k">typeof</span> <span class="nx">foo</span><span class="p">;</span> <span class="c1">// "undefined"</span>
<span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// once block is entered, `foo` becomes declared and available to the entire scope</span>
  <span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="c1">// this block is never entered, and `foo` is never redeclared</span>
  <span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">typeof</span> <span class="nx">foo</span><span class="p">;</span> <span class="c1">// "function"</span></code></pre></div>
  Generally, we can emulate function statements behavior from the previous example with this standards-compliant (and unfortunately, more verbose) code:
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">foo</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">};</span>
<span class="p">}</span></code></pre></div>
        </li>
        <li>
          String representation of functions statements is similar to that of function declarations or named function expressions (and includes identifier — "foo" in this example):
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="nb">String</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span> <span class="c1">// function foo() { return 1; }</span></code></pre></div>
        </li>
        <li>
Finally, what appears to be a bug in earlier Gecko-based implementations (present in &lt;= Firefox 3), is the way function statements overwrite function declarations. Earlier versions were somehow failing to overwrite function declarations with function statements:
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// function declaration</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// overwritting with function statement</span>
  <span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">();</span> <span class="c1">// 1 in FF&lt;= 3, 2 in FF3.5 and later</span>

<span class="c1">// however, this doesn't happen when overwriting function expression</span>
<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>
<span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">();</span> <span class="c1">// 2 in all versions</span></code></pre></div>
        </li>
        </ol>
        <p id="function-statements-in-safari">
          Note that older Safari (at least 1.2.3, 2.0 - 2.0.4 and 3.0.4, and possibly earlier versions too) implement function statements <strong>identically to SpiderMonkey</strong>.
          All examples from this chapter, except the last "bug" one, produce same results in those versions of Safari as they do in, say, Firefox. Another browser that seems to
          follow same semantics is Blackberry one (at least 8230, 9000 and 9530 models). This diversity in behavior demonstrates once again what a bad idea it is to rely on these extensions.
        </p>
      </div>

      <h2 id="named-expr">Named function expressions</h2>

      <p>Function expressions can actually be seen quite often. A common pattern in web development is to “fork” function definitions based on some kind of a feature test, allowing for the best performance. Since such forking usually happens in the same scope, it is almost always necessary to use function expressions. After all, as we know by now, function declarations should not be executed conditionally:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// `contains` is part of "APE Javascript library" (http://dhtmlkitchen.com/ape/) by Garrett Smith</span>
<span class="kd">var</span> <span class="nx">contains</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">docEl</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">docEl</span><span class="p">.</span><span class="nx">compareDocumentPosition</span> <span class="o">!=</span> <span class="s1">'undefined'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">el</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">(</span><span class="nx">el</span><span class="p">.</span><span class="nx">compareDocumentPosition</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">!==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">docEl</span><span class="p">.</span><span class="nx">contains</span> <span class="o">!=</span> <span class="s1">'undefined'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">el</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">el</span> <span class="o">!==</span> <span class="nx">b</span> <span class="o">&amp;&amp;</span> <span class="nx">el</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">el</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">el</span> <span class="o">===</span> <span class="nx">b</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">el</span> <span class="o">!=</span> <span class="nx">b</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">el</span> <span class="o">===</span> <span class="nx">b</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">})();</span></code></pre></div>

<p>Quite obviously, when a function expression has a name (technically — <em>Identifier</em>), it is called a <strong>named function expression</strong>. What you’ve seen in the very first example — <code>var bar = function foo(){};</code> — was exactly that — a named function expression with <code>foo</code> being a function name. An important detail to remember is that this name is <strong>only available in the scope of a newly-defined function</strong>; specs mandate that an identifier should not be available to an enclosing scope:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span>
  <span class="k">return</span> <span class="k">typeof</span> <span class="nx">foo</span><span class="p">;</span> <span class="c1">// "foo" is available in this inner scope</span>
<span class="p">};</span>
<span class="c1">// `foo` is never visible "outside"</span>
<span class="k">typeof</span> <span class="nx">foo</span><span class="p">;</span> <span class="c1">// "undefined"</span>
<span class="nx">f</span><span class="p">();</span> <span class="c1">// "function"</span></code></pre></div>

      <p>So what’s so special about these named function expressions? Why would we want to give them names at all? </p>

      <p>It appears that named functions make for a much more pleasant debugging experience. When debugging an application, having a call stack with descriptive items makes a huge difference.</p>

      <h2 id="names-in-debuggers">Function names in debuggers</h2>

      <p>When a function has a corresponding identifier, debuggers show that identifier as a function name, when inspecting call stack. Some debuggers (e.g. Firebug) helpfully show names of even anonymous functions — making them identical to names of variables that functions are assigned to. Unfortunately, these debuggers usually rely on simple parsing rules; Such extraction is usually quite fragile and often produces false results. </p>

      <p>Let’s look at a simple example:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span>
  <span class="k">return</span> <span class="nx">bar</span><span class="p">();</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">bar</span><span class="p">(){</span>
  <span class="k">return</span> <span class="nx">baz</span><span class="p">();</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">baz</span><span class="p">(){</span>
  <span class="kr">debugger</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">();</span>

<span class="c1">// Here, we used function declarations when defining all of 3 functions</span>
<span class="c1">// When debugger stops at the `debugger` statement,</span>
<span class="c1">// the call stack (in Firebug) looks quite descriptive:</span>
<span class="nx">baz</span>
<span class="nx">bar</span>
<span class="nx">foo</span>
<span class="nx">expr_test</span><span class="p">.</span><span class="nx">html</span><span class="p">()</span></code></pre></div>

      <p>We can see that <code>foo</code> called <code>bar</code> which in its turn called <code>baz</code> (and that <code>foo</code> itself was called from the global scope of <code>expr_test.html</code> document). What’s really nice, is that Firebug manages to parse the “name” of a function even when an anonymous expression is used:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span>
  <span class="k">return</span> <span class="nx">bar</span><span class="p">();</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="k">return</span> <span class="nx">baz</span><span class="p">();</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">baz</span><span class="p">(){</span>
  <span class="kr">debugger</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">();</span>

<span class="c1">// Call stack</span>
<span class="nx">baz</span>
<span class="nx">bar</span><span class="p">()</span>
<span class="nx">foo</span>
<span class="nx">expr_test</span><span class="p">.</span><span class="nx">html</span><span class="p">()</span></code></pre></div>

      <p>What’s not very nice, though, is that if a function expression gets any more complex (which, in real life, it almost always is) all of the debugger’s efforts turn out to be pretty useless; we end up with a shiny question mark in place of a function name:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span>
  <span class="k">return</span> <span class="nx">bar</span><span class="p">();</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="k">return</span> <span class="nx">baz</span><span class="p">();</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">attachEvent</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">baz</span><span class="p">();</span>
    <span class="p">};</span>
  <span class="p">}</span>
<span class="p">})();</span>
<span class="kd">function</span> <span class="nx">baz</span><span class="p">(){</span>
  <span class="kr">debugger</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">();</span>

<span class="c1">// Call stack</span>
<span class="nx">baz</span>
<span class="p">(</span><span class="o">?</span><span class="p">)()</span>
<span class="nx">foo</span>
<span class="nx">expr_test</span><span class="p">.</span><span class="nx">html</span><span class="p">()</span></code></pre></div>

      <p>Another confusion appears when a function is being assigned to more than one variable:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span>
  <span class="k">return</span> <span class="nx">baz</span><span class="p">();</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="kr">debugger</span><span class="p">;</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">baz</span> <span class="o">=</span> <span class="nx">bar</span><span class="p">;</span>
<span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="s1">'spoofed'</span><span class="p">);</span>
<span class="p">};</span>
<span class="nx">foo</span><span class="p">();</span>

<span class="c1">// Call stack:</span>
<span class="nx">bar</span><span class="p">()</span>
<span class="nx">foo</span>
<span class="nx">expr_test</span><span class="p">.</span><span class="nx">html</span><span class="p">()</span></code></pre></div>

      <p>You can see call stack showing that <code>foo</code> invoked <code>bar</code>. Clearly, that’s not what has happened. The confusion is due to the fact that <code>baz</code> was “exchanged” references with another function — the one alerting “spoofed”. As you can see, such parsing — while great in simple cases — is often useless in any non-trivial script. </p>

      <p>What it all boils down to is the fact that named <strong>function expressions is the only way to get a truly robust stack inspection</strong>. Let’s rewrite our previous example with named functions in mind. Notice how both of the functions returning from self-executing wrapper, are named as <code>bar</code>:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span>
  <span class="k">return</span> <span class="nx">bar</span><span class="p">();</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="nx">bar</span><span class="p">(){</span>
      <span class="k">return</span> <span class="nx">baz</span><span class="p">();</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">attachEvent</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">baz</span><span class="p">();</span>
    <span class="p">};</span>
  <span class="p">}</span>
<span class="p">})();</span>
<span class="kd">function</span> <span class="nx">baz</span><span class="p">(){</span>
  <span class="kr">debugger</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">();</span>

<span class="c1">// And, once again, we have a descriptive call stack!</span>
<span class="nx">baz</span>
<span class="nx">bar</span>
<span class="nx">foo</span>
<span class="nx">expr_test</span><span class="p">.</span><span class="nx">html</span><span class="p">()</span></code></pre></div>

      <p>Before we start dancing happily celebrating this holy grail finding, I’d like to bring a beloved JScript into the picture.</p>

      <h2 id="jscript-bugs">JScript bugs</h2>

      <p>Unfortunately, JScript (i.e. Internet Explorer’s ECMAScript implementation) seriously messed up named function expressions. JScript is responsible for named function expressions <strong>being recommended against</strong> by many people these days. It's also quite sad that even <strong>last version of JScript — 5.8 — used in Internet Explorer 8, still exhibits every single quirk described below</strong></p>

      <p>Let’s look at what exactly is wrong with its broken implementation. Understanding all of its issues will allow us to work around them safely. Note that I broke these discrepancies into few examples — for clarity — even though all of them are most likely a consequence of one major bug.</p>

      <h3 id="example_1_function_expression_identifier_leaks_into_an_enclosing_scope">Example #1: Function expression identifier leaks into an enclosing scope</h3>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">g</span><span class="p">(){};</span>
<span class="k">typeof</span> <span class="nx">g</span><span class="p">;</span> <span class="c1">// "function"</span></code></pre></div>

      <p>Remember how I mentioned that an identifier of named function expression is <strong>not available in an enclosing scope</strong>? Well, JScript doesn’t agree with specs on this one — <code>g</code> in the above example resolves to a function object. This is a most widely observed discrepancy. It’s dangerous in that it inadvertedly pollutes an enclosing scope — a scope that might as well be a global one — with an extra identifier. Such pollution can, of course, be a source of hard-to-track bugs.</p>

      <h3 id="example_2_named_function_expression_is_treated_as_both_function_declaration_and_function_expression">Example #2: Named function expression is treated as BOTH — function declaration AND function expression</h3>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="k">typeof</span> <span class="nx">g</span><span class="p">;</span> <span class="c1">// "function"</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">g</span><span class="p">(){};</span></code></pre></div>

      <p>As I explained before, function declarations are parsed foremost any other expressions in a particular execution context. The above example demonstrates how <strong>JScript actually treats named function expressions as function declarations</strong>. You can see that it parses <code>g</code> before an “actual declaration” takes place. </p>

      <p>This brings us to a next example:</p>

      <h3 id="example_3_named_function_expression_creates_two_distinct_function_objects">Example #3: Named function expression creates TWO DISTINCT function objects!</h3>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">g</span><span class="p">(){};</span>
<span class="nx">f</span> <span class="o">===</span> <span class="nx">g</span><span class="p">;</span> <span class="c1">// false</span>

<span class="nx">f</span><span class="p">.</span><span class="nx">expando</span> <span class="o">=</span> <span class="s1">'foo'</span><span class="p">;</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">expando</span><span class="p">;</span> <span class="c1">// undefined</span></code></pre></div>

      <p>This is where things are getting interesting. Or rather — completely nuts. Here we are seeing the dangers of having to deal with two distinct objects — augmenting one of them obviously does not modify the other one; This could be quite troublesome if you decided to employ, say, caching mechanism and store something in a property of <code>f</code>, then tried accessing it as a property of <code>g</code>, thinking that it is the same object you’re working with.</p>

      <p>Let’s look at something a bit more complex.</p>

      <h3 id="example_4_function_declarations_are_parsed_sequentially_and_are_not_affected_by_conditional_blocks">Example #4: Function declarations are parsed sequentially and are not affected by conditional blocks</h3>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">g</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">if</span> <span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">g</span><span class="p">(){</span>
    <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>
<span class="nx">g</span><span class="p">();</span> <span class="c1">// 2</span></code></pre></div>

      <p>An example like this could cause even harder to track bugs. What happens here is actually quite simple. First, <code>g</code> is being parsed as a function declaration, and since declarations in JScript are independent of conditional blocks, <code>g</code> is being declared as a function from the “dead” <code>if</code> branch — <code>function g(){ return 2 }</code>. Then all of the “regular” expressions are being evaluated and <code>f</code> is being assigned another, newly created function object to. “dead” <code>if</code> branch is never entered when evaluating expressions, so <code>f</code> keeps referencing first function — <code>function g(){ return 1 }</code>. It should be clear by now, that if you’re not careful enough, and call <code>g</code> from within <code>f</code>, you’ll end up calling a completely unrelated <code>g</code> function object.</p>

      <p>You might be wondering how all this mess with different function objects compares to <code>arguments.callee</code>. Does <code>callee</code> reference <code>f</code> or <code>g</code>? Let’s take a look:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">g</span><span class="p">(){</span>
  <span class="k">return</span> <span class="p">[</span>
    <span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span> <span class="o">==</span> <span class="nx">f</span><span class="p">,</span>
    <span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span> <span class="o">==</span> <span class="nx">g</span>
  <span class="p">];</span>
<span class="p">};</span>
<span class="nx">f</span><span class="p">();</span> <span class="c1">// [true, false]</span>
<span class="nx">g</span><span class="p">();</span> <span class="c1">// [false, true]</span></code></pre></div>

      <p>As you can see, <code>arguments.callee</code> references whatever function is being invoked. This is actually good news, as you will see later on.</p>

      <p>Another interesting example of "unexpected behavior" can be observed when using named <strong>function expression in undeclared assignment</strong>, but only when function is "named" the same way as identifier it's being assigned to:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">(){};</span>
<span class="p">})();</span></code></pre></div>
      <p>As you might know, undeclared assignment (which is <strong>not recommended</strong> and is only used here for demonstration purposes) should result in creation of global <code>f</code> property. This is exactly what happens in conforming implementations. However, JScript bug makes things a bit more confusing. Since named function expression is parsed as function declaration (see <a href="#example_2_named_function_expression_is_treated_as_both_function_declaration_and_function_expression">example #2</a>), what happens here is that <code>f</code> becomes declared as a local variable during the phase of variable declarations. Later on, when function execution begins, assignment is no longer undeclared, so <code>function f(){}</code> on the right hand side is simply assigned to this newly created <strong>local</strong> <code>f</code> variable. Global <code>f</code> is never created.</p>

      <p>This demonstrates how failing to understand JScript peculiarities can lead to drastically different behavior in code.</p>

      <p>Looking at JScript deficiencies, it becomes pretty clear what exactly we need to avoid. First, we need <strong>to be aware of a leaking identifier</strong> (so that it doesn’t pollute enclosing scope). Second, we should <strong>never reference identifier used as a function name</strong>; A troublesome identifier is <code>g</code> from the previous examples. Notice how many ambiguities could have been avoided if we were to forget about <code>g</code>’s existance. Always referencing function via <code>f</code> or <code>arguments.callee</code> is the key here. If you use named expression, think of that name as something that’s only being used for debugging purposes. And finally, a bonus point is to <strong>always clean up an extraneous function</strong> created erroneously during NFE declaration.</p>

      <p>I think last point needs a bit of an explanation:</p>

      <h2 id="jscript-memory-management">JScript memory management</h2>

      <p>Being familiar with JScript discrepancies, we can now see a potential problem with memory consumption when using these buggy constructs. Let’s look at a simple example:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="nx">g</span><span class="p">(){};</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="nx">g</span><span class="p">(){};</span>
<span class="p">})();</span></code></pre></div>

      <p>We know that a function returned from within this anonymous invocation — the one that has <code>g</code> identifier — is being assigned to outer <code>f</code>. We also know that named function expressions produce superfluous function object, and that this object is not the same as returned function. The memory issue here is caused by this extraneous <code>g</code> function being literally “trapped” in a closure of returning function. This happens because inner function is declared in the same scope as that pesky <code>g</code> one. Unless we <strong>explicitly break reference to <code>g</code> function</strong> it will keep consuming memory.</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">g</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">g</span><span class="p">(){};</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">g</span><span class="p">(){};</span>
  <span class="p">}</span>
  <span class="c1">// null `g`, so that it doesn't reference extraneous function any longer</span>
  <span class="nx">g</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">f</span><span class="p">;</span>
<span class="p">})();</span></code></pre></div>

      <p>Note that we explicitly declare <code>g</code> as well, so that <code>g = null</code> assignment wouldn’t create a global <code>g</code> variable in conforming clients (i.e. non-JScript ones). By <code>null</code>ing reference to <code>g</code>, we allow garbage collector to wipe off this implicitly created function object that <code>g</code> refers to.</p>

      <p>When taking care of JScript NFE memory leak, I decided to run a simple series of tests to confirm that <code>null</code>ing <code>g</code> actually does free memory.</p>

      <h2 id="tests">Tests</h2>

      <p>The test was simple. It would simply create 10000 functions via named function expressions and store them in an array. I would then wait for about a minute and check how high the memory consumption is. After that I would null-out the reference and repeat the procedure again. Here’s a test case I used:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">createFn</span><span class="p">(){</span>
  <span class="k">return</span> <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">f</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">F</span><span class="p">(){</span>
        <span class="k">return</span> <span class="s1">'standard'</span><span class="p">;</span>
      <span class="p">};</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">F</span><span class="p">(){</span>
        <span class="k">return</span> <span class="s1">'alternative'</span><span class="p">;</span>
      <span class="p">};</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">F</span><span class="p">(){</span>
        <span class="k">return</span> <span class="s1">'fallback'</span><span class="p">;</span>
      <span class="p">};</span>
    <span class="p">}</span>
    <span class="c1">// var F = null;</span>
    <span class="k">return</span> <span class="nx">f</span><span class="p">;</span>
  <span class="p">})();</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span> <span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="mi">10000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">createFn</span><span class="p">();</span>
<span class="p">}</span></code></pre></div>

      <p>Results as seen in Process Explorer on Windows XP SP2 were:</p>

<pre>  IE6:

    without `null`:   7.6K -&gt; 20.3K
    with `null`:      7.6K -&gt; 18K

  IE7:

    without `null`:   14K -&gt; 29.7K
    with `null`:      14K -&gt; 27K
</pre>

      <p>The results somewhat confirmed my assumptions — explicitly nulling superfluous reference did free memory, but the difference in consumption was relatively insignificant. For 10000 function objects, there would be a ~3MB difference. This is definitely something that should be kept in mind when designing large-scale applications, applications that will run for either long time or on devices with limited memory (such as mobile devices). For any small script, the difference probably doesn’t matter.</p>

      <p>You might think that it’s all finally over, but we are not just quite there yet :) There’s a tiny little detail that I’d like to mention and that detail is Safari 2.x</p>

      <h2 id="safari-bug">Safari bug</h2>

      <p>
      Even less widely known bug with NFE is present in older versions of Safari; namely, Safari 2.x series. I’ve seen some <a href="http://meyerweb.com/eric/thoughts/2005/07/11/safari-syntaxerror/">claims on the web</a> that Safari 2.x does not support NFE at all. This is not true. Safari does support it, but has bugs in its implementation which you will see shortly.</p>

      <p>When encountering function expression in a certain context, Safari 2.x fails to parse the program entirely. It doesn’t throw any errors (such as <code>SyntaxError</code> ones). It simply bails out:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="p">(</span><span class="kd">function</span> <span class="nx">f</span><span class="p">(){})();</span> <span class="c1">// &lt;== NFE</span>
<span class="nx">alert</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// this line is never reached, since previous expression fails the entire program</span></code></pre></div>

      <p>After fiddling with various test cases, I came to conclusion that Safari 2.x <strong>fails to parse named function expressions, if those are not part of assignment expressions</strong>. Some examples of assignment expressions are:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// part of variable declaration</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// part of simple assignment</span>
<span class="nx">f</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">g</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="c1">// part of return statement</span>
<span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">f</span> <span class="o">=</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">})();</span></code></pre></div>

      <p>This means that putting named function expression into an assignment makes Safari “happy”:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="p">(</span><span class="kd">function</span> <span class="nx">f</span><span class="p">(){});</span> <span class="c1">// fails</span>

<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">(){};</span> <span class="c1">// works</span>

<span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">(){};</span> <span class="c1">// fails</span>
<span class="p">})();</span>

<span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">(){});</span> <span class="c1">// works</span>
<span class="p">})();</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="nx">f</span><span class="p">(){</span> <span class="p">},</span> <span class="mi">100</span><span class="p">);</span> <span class="c1">// fails</span>

<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">say</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">say</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// fails</span>
<span class="p">}</span>

<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">say</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">say</span><span class="p">(){</span> <span class="p">...</span> <span class="p">};</span> <span class="c1">// works</span></code></pre></div>

      <p>It also means that we can’t use such common pattern as returning named function expression without an assignment:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// Instead of this non-Safari-2x-compatible syntax:</span>
<span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">featureTest</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">(){};</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">(){};</span>
<span class="p">})();</span>

<span class="c1">// we should use this slightly more verbose alternative:</span>
<span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">f</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">featureTest</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">(){};</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">(){};</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">f</span><span class="p">;</span>
<span class="p">})();</span>

<span class="c1">// or another variation of it:</span>
<span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">f</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">featureTest</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">(){});</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">(){});</span>
<span class="p">})();</span>

<span class="cm">/*</span>
<span class="cm">  Unfortunately, by doing so, we introduce an extra reference to a function</span>
<span class="cm">  which gets trapped in a closure of returning function. To prevent extra memory usage,</span>
<span class="cm">  we can assign all named function expressions to one single variable.</span>
<span class="cm">*/</span>

<span class="kd">var</span> <span class="nx">__temp</span><span class="p">;</span>

<span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">featureTest</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="nx">__temp</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">(){});</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">__temp</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">(){});</span>
<span class="p">})();</span>

<span class="p">...</span>

<span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">featureTest2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="nx">__temp</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">g</span><span class="p">(){});</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">__temp</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">g</span><span class="p">(){});</span>
<span class="p">})();</span>

<span class="cm">/*</span>
<span class="cm">  Note that subsequent assignments destroy previous references,</span>
<span class="cm">  preventing any excessive memory usage.</span>
<span class="cm">*/</span></code></pre></div>

      <p>If Safari 2.x compatibility is important, we need to make sure <strong>“incompatible” constructs do not even appear in the source</strong>. This is of course quite irritating, but is definitely possible to achieve, especially when knowing the root of the problem.</p>

      <p>It’s also worth mentioning that declaring a function as NFE in Safari 2.x exhibits another minor glitch, where function representation does not contain function identifier:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">g</span><span class="p">(){};</span>

<span class="c1">// Notice how function representation is lacking `g` identifier</span>
<span class="nb">String</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span> <span class="c1">// function () { }</span></code></pre></div>

      <p>This is not really a big deal. As I have already mentioned before, function decompilation is something that <a href="http://perfectionkills.com/those-tricky-functions/">should not be relied upon</a> anyway. </p>

      <h2 id="spidermonkey-peculiarity">SpiderMonkey peculiarity</h2>

      <p>
        We know that identifier of named function expression is only available to the local scope of a function.
        But how does this "magic" scoping actually happen? It appears to be very simple.
        When named function expression is evaluated, a <strong>special object is created</strong>.
        The sole purpose of that object is to hold a property with the name corresponding to function identifier, and value corresponding to function itself.
        That object is then injected into the front of the current scope chain, and this "augmented" scope chain is then used to initialize a function.
      </p>

      <p>
        The interesting part here, however, is the way ECMA-262 defines this "special" object — the one that holds function identifier.
        Spec says that an object is created <strong>"as if by expression new Object()"</strong> which, when interpreted literally,
        makes this object an instance of built-in <code>Object</code> constructor. However, only one implementation — SpiderMonkey —
        followed this specification requirement literally. In SpiderMonkey, it is possible to interfere with function local variables by augmenting <code>Object.prototype</code>:
      </p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="s1">'outer'</span><span class="p">;</span>

<span class="p">(</span><span class="kd">function</span><span class="p">(){</span>

  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="s1">'inner'</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    `foo` function here has a special object in its scope chain — to hold an identifier. That object is practically a —</span>
<span class="cm">    `{ foo: &lt;function object&gt; }`. When `x` is being resolved through the scope chain, it is first searched for in</span>
<span class="cm">    `foo`'s local context. When not found, it is searched in the next object from the scope chain. That object turns out</span>
<span class="cm">    to be the one that holds identifier — { foo: &lt;function object&gt; } and since it inherits from `Object.prototype`,</span>
<span class="cm">    `x` is found right here, and is the one that's `Object.prototype.x` (with value of 'outer'). Outer function's scope</span>
<span class="cm">    (with x === 'inner') is never even reached.</span>
<span class="cm">  */</span>

  <span class="p">(</span><span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span>

    <span class="nx">alert</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// alerts `outer`</span>

  <span class="p">})();</span>
<span class="p">})();</span></code></pre></div>

<p>
  Note that later versions of SpiderMonkey actually <strong>changed this behavior</strong>,
  as it was probably considered a security hole. A "special" object no longer inherits from <code>Object.prototype</code>.
  You can, however, still see it in Firefox &lt;=3.
</p>

<p id="activation-object-in-blackberry-browser">
  Another environment implementing internal object as an instance of global <code>Object</code> is <strong>Blackberry browser</strong>.
  Only this time, it's <em>Activation Object</em> that inherits from <code>Object.prototype</code>. Note that specification actually
  doesn't codify <em>Activation Object</em> to be created "as if by expression new Object()" (as is the case with NFE's identifier holder object).
  It states that <em>Activation Object</em> is merely a specification mechanism.
</p>

<p>So, let's see what happens in Blackberry browser:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="s1">'outer'</span><span class="p">;</span>

<span class="p">(</span><span class="kd">function</span><span class="p">(){</span>

  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="s1">'inner'</span><span class="p">;</span>

  <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>

    <span class="cm">/*</span>
<span class="cm">    When `x` is being resolved against scope chain, this local function's Activation Object is searched first.</span>
<span class="cm">    There's no `x` in it, of course. However, since Activation Object inherits from `Object.prototype`, it is</span>
<span class="cm">    `Object.prototype` that's being searched for `x` next. `Object.prototype.x` does in fact exist and so `x`</span>
<span class="cm">    resolves to its value — 'outer'. As in the previous example, outer function's scope (Activation Object)</span>
<span class="cm">    with its own x === 'inner' is never even reached.</span>
<span class="cm">    */</span>

    <span class="nx">alert</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// alerts 'outer'</span>

  <span class="p">})();</span>
<span class="p">})();</span></code></pre></div>

<p>
  This might look bizarre, but what's really disturbing is that there's even more chance of conflict with
  already existing <code>Object.prototype</code> members:
</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>

  <span class="kd">var</span> <span class="nx">constructor</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>

  <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>

    <span class="nx">constructor</span><span class="p">();</span> <span class="c1">// evaluates to an object `{ }`, not `1`</span>

    <span class="nx">constructor</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span><span class="p">;</span> <span class="c1">// true</span>
    <span class="nx">toString</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">;</span> <span class="c1">// true</span>

    <span class="c1">// etc.</span>

  <span class="p">})();</span>
<span class="p">})();</span></code></pre></div>

<p>
  Solution to this Blackberry discrepancy is obvious: avoid naming variables as <code>Object.prototype</code> properties
  — <code>toString</code>, <code>valueOf</code>, <code>hasOwnProperty</code>, and so on.
</p>

      <h2 id="solution">JScript solution</h2>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">fn</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>

  <span class="c1">// declare a variable to assign function object to</span>
  <span class="kd">var</span> <span class="nx">f</span><span class="p">;</span>

  <span class="c1">// conditionally create a named function</span>
  <span class="c1">// and assign its reference to `f`</span>
  <span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">F</span><span class="p">(){</span> <span class="p">};</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">F</span><span class="p">(){</span> <span class="p">};</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">F</span><span class="p">(){</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="c1">// Assign `null` to a variable corresponding to a function name</span>
  <span class="c1">// This marks the function object (referred to by that identifier)</span>
  <span class="c1">// available for garbage collection</span>
  <span class="kd">var</span> <span class="nx">F</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

  <span class="c1">// return a conditionally defined function</span>
  <span class="k">return</span> <span class="nx">f</span><span class="p">;</span>
<span class="p">})();</span></code></pre></div>

      <p>Finally, here’s how we would apply this “techinque” in real life, when writing something like a cross-browser <code>addEvent</code> function:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// 1) enclose declaration with a separate scope</span>
<span class="kd">var</span> <span class="nx">addEvent</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>

  <span class="kd">var</span> <span class="nx">docEl</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">;</span>

  <span class="c1">// 2) declare a variable to assign function to</span>
  <span class="kd">var</span> <span class="nx">fn</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">docEl</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 3) make sure to give function a descriptive identifier</span>
    <span class="nx">fn</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">addEvent</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">eventName</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">element</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="nx">eventName</span><span class="p">,</span> <span class="nx">callback</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">docEl</span><span class="p">.</span><span class="nx">attachEvent</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fn</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">addEvent</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">eventName</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">element</span><span class="p">.</span><span class="nx">attachEvent</span><span class="p">(</span><span class="s1">'on'</span> <span class="o">+</span> <span class="nx">eventName</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="nx">fn</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">addEvent</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">eventName</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">element</span><span class="p">[</span><span class="s1">'on'</span> <span class="o">+</span> <span class="nx">eventName</span><span class="p">]</span> <span class="o">=</span> <span class="nx">callback</span><span class="p">;</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="c1">// 4) clean up `addEvent` function created by JScript</span>
  <span class="c1">//    make sure to either prepend assignment with `var`,</span>
  <span class="c1">//    or declare `addEvent` at the top of the function</span>
  <span class="kd">var</span> <span class="nx">addEvent</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

  <span class="c1">// 5) finally return function referenced by `fn`</span>
  <span class="k">return</span> <span class="nx">fn</span><span class="p">;</span>
<span class="p">})();</span></code></pre></div>

      <h2 id="alt-solution">Alternative solution</h2>

      <p>It’s worth mentioning that there actually exist alternative ways of having descriptive names in call stacks. Ways that don’t require one to use named function expressions. First of all, it is often possible to define function via declaration, rather than via expression. This option is only viable when you don’t need to create more than one function:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">hasClassName</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>

  <span class="c1">// define some private variables</span>
  <span class="kd">var</span> <span class="nx">cache</span> <span class="o">=</span> <span class="p">{</span> <span class="p">};</span>

  <span class="c1">// use function declaration</span>
  <span class="kd">function</span> <span class="nx">hasClassName</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">className</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">_className</span> <span class="o">=</span> <span class="s1">'(?:^|\\s+)'</span> <span class="o">+</span> <span class="nx">className</span> <span class="o">+</span> <span class="s1">'(?:\\s+|$)'</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">re</span> <span class="o">=</span> <span class="nx">cache</span><span class="p">[</span><span class="nx">_className</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="nx">cache</span><span class="p">[</span><span class="nx">_className</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">RegExp</span><span class="p">(</span><span class="nx">_className</span><span class="p">));</span>
    <span class="k">return</span> <span class="nx">re</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">className</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// return function</span>
  <span class="k">return</span> <span class="nx">hasClassName</span><span class="p">;</span>
<span class="p">})();</span></code></pre></div>

      <p>This obviously wouldn’t work when forking function definitions. Nevertheless, there’s an interesting pattern that I first seen used by <a href="http://tobielangel.com/">Tobie Langel</a>. The way it works is by <strong>defining all functions upfront using function declarations, but giving them slightly different identifiers</strong>:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">addEvent</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>

  <span class="kd">var</span> <span class="nx">docEl</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">addEventListener</span><span class="p">(){</span>
    <span class="cm">/* ... */</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">attachEvent</span><span class="p">(){</span>
    <span class="cm">/* ... */</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">addEventAsProperty</span><span class="p">(){</span>
    <span class="cm">/* ... */</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">docEl</span><span class="p">.</span><span class="nx">addEventListener</span> <span class="o">!=</span> <span class="s1">'undefined'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">addEventListener</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">docEl</span><span class="p">.</span><span class="nx">attachEvent</span> <span class="o">!=</span> <span class="s1">'undefined'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">attachEvent</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">addEventAsProperty</span><span class="p">;</span>
<span class="p">})();</span></code></pre></div>

      <p>While it’s an elegant approach, it has its own drawbacks. First, by using different identifiers, you lose naming consistency. Whether it’s good or bad thing is not very clear. Some might prefer to have identical names, while others wouldn’t mind varying ones; after all, different names can often “speak” about implementation used. For example, seeing “attachEvent” in debugger, would let you know that it is an <code>attachEvent</code>-based implementation of <code>addEvent</code>. On the other hand, implementation-related name might not be meaningful at all. If you’re providing an API and name “inner” functions in such way, the user of API could easily get lost in all of these implementation details. </p>

      <p>A solution to this problem might be to employ different naming convention. Just be careful not to introduce extra verbosity. Some alternatives that come to mind are:</p>

<pre>  `addEvent`, `altAddEvent` and `fallbackAddEvent`
  // or
  `addEvent`, `addEvent2`, `addEvent3`
  // or
  `addEvent_addEventListener`, `addEvent_attachEvent`, `addEvent_asProperty`
</pre>

      <p>Another minor issue with this pattern is increased memory consumption. By defining all of the function variations upfront, you implicitly create N-1 unused functions. As you can see, if <code>attachEvent</code> is found in <code>document.documentElement</code>, then neither <code>addEventListener</code> nor <code>addEventAsProperty</code> are ever really used. Yet, they already consume memory; memory which is never deallocated for the same reason as with JScript’s buggy named expressions — both functions are “trapped” in a closure of returning one. </p>

      <p>This increased consumption is of course hardly an issue. If a library such as Prototype.js was to use this pattern, there would be not more than 100-200 extra function objects created. As long as functions are not created in such way repeatedly (at runtime) but only once (at load time), you probably shouldn’t worry about it.</p>

      <h2 id="webkit-displayName">WebKit's displayName</h2>

      <p>A somewhat different approach was taken by WebKit team. Frustrated with poor representation of functions — both, anonymous and named — WebKit introduced "special" <code>displayName</code> property (essentially a string) that when assigned to a function is displayed in debugger/profiler in place of that function's "name". <a href="http://www.alertdebugging.com/2009/04/29/building-a-better-javascript-profiler-with-webkit/">Francisco Tolmasky explains in details</a> the rationale and implementation of this solution.</p>

      <h2 id="future-considerations">Future considerations</h2>

      <p>Upcoming version of ECMAScript — <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm" title="Standard ECMA-262">ECMA-262, 5th edition</a> — introduces so-called <strong>strict mode</strong>. The purpose of strict mode is to disallow certain parts of the language which are considered to be fragile, unreliable or dangerous. One of such parts is <code>arguments.callee</code>, "banned" presumably due to security concerns. When in strict mode, access to <code>arguments.callee</code> results in <code>TypeError</code> (see section 10.6). The reason I'm bringing up strict mode is because inability to use <code>arguments.callee</code> for recursion in 5th edition will most likely result in increased use of named function expressions. Understanding their semantics and bugs will become even more important.</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// Before, you could use arguments.callee</span>
<span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">})(</span><span class="mi">10</span><span class="p">);</span>

<span class="c1">// In strict mode, an alternative solution is to use named function expression</span>
<span class="p">(</span><span class="kd">function</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">})(</span><span class="mi">10</span><span class="p">);</span>

<span class="c1">// or just fall back to slightly less flexible function declaration</span>
<span class="kd">function</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">factorial</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span></code></pre></div>

      <h2 id="credits">Credits</h2>

      <p><strong><em>Richard Cornford</em></strong>, for being one of the first people <a href="http://groups.google.com/group/comp.lang.javascript/msg/5b508b03b004bce8">to explain JScript bug with named function expressions</a>. Richard explains most of the bugs mentioned in this article. I highly recommend reading his explanation. I would also like to thank <strong><em>Yann-Erwan Perio</em></strong> and <strong><em>Douglas Crockford</em></strong> for <a href="http://groups.google.com/group/comp.lang.javascript/msg/03d53d114d176323">mentioning and discussing NFE issues in comp.lang.javascript</a> as far back as in 2003.</p>

      <p><strong><em>John-David Dalton</em></strong>, for giving useful suggestions about “final solution”.</p>

      <p><strong><em>Tobie Langel</em></strong>, for ideas presented in “alternative solution”.</p>

      <p><strong><em>Garrett Smith</em></strong> and <strong><em>Dmitry A. Soshnikov</em></strong> for various additions and corrections.</p>

      <p>For an extensive explanation of functions in ECMAScript in Russian, see <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-5-functions/">this article by Dmitry A. Soshnikov</a>.</p>

      <div class="footer clearfix">
        <div class="row">
          <div class="col-md-7">
            <p class="bg-info">
              Have suggestions or corrections?
              Feel free to <a href="http://perfectionkills.com/named-function-expressions-demystified/">comment on a blog post</a>
              or <a href="mailto:kangax@gmail.com">drop me an email</a>.
              <br>
              This <a href="https://github.com/kangax/nfe" title="this article on GitHub">article is also versioned on GitHub</a>, where you can track its changes.
            </p>
          </div>
          <div class="col-md-4 col-md-offset-1 footer-right">
            <p>
              Created: <span class="bg-info"><strong>June 17, 2009</strong></span> Last modified: <span class="bg-info"><strong>August 04, 2014</strong></span>
            </p>
          </div>
        </div>
      </div>
    </div>

    <script></script>
  

</body></html>