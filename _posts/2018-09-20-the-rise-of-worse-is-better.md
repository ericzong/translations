---
layout: post
title: “更糟糕的更好”设计理念的兴起
category: 编程理论
tags: 设计
excerpt: 这是一篇摘录，摘自一篇讨论Lisp语言的文章关于设计理念的部分。
author: "Eric Zong"
date: 2018-09-20 21:53
---

* content
{:toc}

> 英文原文：[The Rise of Worse is Better](http://dreamsongs.com/RiseOfWorseIsBetter.html)
>
> 原文作者：Richard P. Gabriel (Lucid, Inc)
>
> 翻译参考：<http://blog.sina.com.cn/s/blog_66d65c7d0100sw82.html>

{从["Lisp: Good News, Bad News, How to Win Big."](http://dreamsongs.com/WIB.html)摘录}

# 2.1 “更糟糕的更好”设计理念的兴起

我和Common Lisp和CLOS(Common Lisp Object System)的几乎每一位设计师都对麻省理工学院/斯坦福大学(MIT/Stanford)的设计风格极度了解（extreme exposure）。这种风格的精髓可以从“正确的做法(the right thing)”这个短语中捕捉到。对于这样的设计师，重要的是彻底搞清楚下列所有特性：

* 简单性——设计必须简单，无论是在实现上还是在接口上。接口的简单要比实现的简单更加重要。
* 正确性——设计必须在所有可观察的方面都是正确的。不正确是绝对不允许的。
* 一致性——设计必须保持一致兼容。为了避免不一致，设计上允许略微不那么简单完整。一致性和正确性同等重要。
* 完整性——设计必须涵盖尽可能多的重要情况，这是切实可行的。所有合理预期的情况都必须涵盖到。简单性不能过度的损害完整性。

我相信大多数人都会同意，这都是一些好的特性。我把这种设计理念的运用称为“麻省理工方法(MIT approach)”。Common Lisp(包括CLOS)和Scheme代表着麻省理工方法的设计和实现。

“更糟糕的更好(Worse is Better)”的理念只是稍微有点不同：

* 简单性——设计必须简单，无论是在实现上还是在接口上。实现的简单要比接口的简单更加重要。设计中，简单性是最重要的考量。
* 正确性——设计必须在所有可观察的方面都是正确的。为了简单性，正确性可以做轻微的让步。
* 一致性——设计不能过度不一致。为了简单，一致性可以在某些方面做些牺牲，但与其引入实现复杂性和不一致性，不如删除设计中处理不太普遍情况的那些部分。
* 完整性——设计必须涵盖尽可能多的重要情况，这是切实可行的。所有合理预期的情况都必须涵盖到。在有利于任何其它（特性的）品质的情况下，完整性可以牺牲。事实上，当实现的简单性受到损害时，就必须牺牲完整性。如果保有简单性，可以牺牲一致性来实现完整性；尤为无用的是接口的一致性。

早期的Unix和C语言是使用这种设计学派的例子，我把这种设计策略的运用称为“新泽西方法(New Jersey approach)”。我故意讽刺“更糟糕的更好”的理念，让你相信它显然是一种不好的理念，而新泽西方法是一种不好的（软件实现）方法。

然而，即使在这种假象（strawman form）下，我相信“更糟糕的更好”理念也要比“正确的做法”理念有更大的生存空间，并且对于软件而言，新泽西方法要比麻省理工方法更实用。

让我来复述一个故事，它表明麻省理工方法和新泽西方法之间的差别是存在（valid）的，以及各个理念的支持者实际上都相信他们的理念更好。

两位著名的人物，一位是来自麻省理工，另一位来自伯克利学院(但是正在研究Unix)，曾见面一起讨论操作系统问题。来自麻省理工的人对 ITS（麻省理工学院人工智能实验室的操作系统）非常熟悉，并一直在阅读Unix的源代码。他对Unix如何解决PC loser-ing问题感兴趣。 当用户程序调用系统例程以执行可能具有重要状态(如IO缓冲区)的长时间操作时，就会出现PC失败问题。如果在操作期间发生中断，则必须保存用户程序的状态。由于系统例程的调用通常是一条指令，用户程序的PC程序不能充分捕获进程的状态。系统例程要么退出（back out），要么强行继续运行（press forward）。“正确的做法”是退出，并将用户程序PC恢复到调用系统例程的指令，以便在中断后恢复用户程序，例如，重新进入系统例程。这被称为“PC loser-ing”，因为PC机被强迫进入“loser模式”，这里，“loser”是麻省理工对“用户”的一种爱称（the affectionate name）。

这个麻省理工的人没有看到有任何的用来处理这种情况的代码，于是问那个新泽西人，这种问题是如何处理的。新泽西人说，Unix的人意识到了这个问题，但解决方案是针对系统例程通常能正常完成的情况的，但有时会返回错误代码，这表明系统例程没有完成它的操作。然后，一个正确的用户程序需要检查错误码来决定是否简单地重试该系统例程。麻省理工的人不喜欢这个解决方案，因为这不是“正确的做法”。

新泽西人说，Unix的解决方案是正确的，因为Unix的设计理念是追求简单性，而“正确的做法”太复杂。此外，程序员可以容易地插入额外的测试和循环。麻省理工的人指出，这种实现确实简单，但接口的功能是复杂的。新泽西人指出，Unix选择了正确的折衷方案——即实现简单性比接口简单性更重要。

麻省理工的人喃喃地说：有时严谨决定一切，但新泽西人不明白（我不确定是否我也不明白）。

现在，我想说“更糟糕的更好”确实是更好。C语言是一种为开发Unix而设计的程序语言，它是使用新泽西方法设计的。C语言因此是一种很容易就能写出像样的编译器的语言，它要求程序员编写易于编译器解释的文本。有些人称C语言为高级（fancy）汇编语言。早期的Unix和C编译器都具有简单的结构，易于移植，运行所需的硬件资源很少，并且提供了你想从一个操作系统和编程语言里得到50%-80%的功能。

在任何时刻存在的计算机一半都比中值差(较小或更慢)。Unix和C语言在它们上面运行良好。“更糟糕的更好”理念表明，实现的简单性具有最高的优先级，这意味着Unix和C语言很容易在这些机器上进行移植。因此，一种预期是，如果Unix和C语言支持的50%的功能令人满意，那它们将开始出现在任何地方。对吧，不是吗？

Unix和C语言是终极电脑病毒。

“更糟糕的更好”理念另外一个好处是，程序员习惯于牺牲一些安全、方便和分歧（hassle），以获得良好的性能和适度的资源使用。使用新泽西方法编写的程序在小型和大型机器上都能很好地工作，而且代码将是可移植的，因为它是在病毒的基础上编写的。

重要的是要记住，最初的病毒基本上是好用的。 如果是这样的话，只要病毒可移植，病毒的传播就会得到保证。 一旦病毒传播，就会有改进它的压力，可能是通过将其功能提高到90%，但是用户已经习惯于接受更糟糕的而不是正确的做法。因此，“更糟糕的更好”的软件首先将获得接受，第二将使用户习惯于更少的期望，第三将被改进到一个近乎“正确的做法”的程度。具体而言，在1987年，即使Lisp编译器和C编译器都一样优秀，但是有更多的编译器专家希望让C编译器变得更好，而不是希望让Lisp编译器变得更好。

好消息是，1995年我们将有一个良好的操作系统和编程语言；而坏消息是，它们将分别是Unix和C++。

“更糟糕的更好”还有最后一个好处。因为一个新泽西式的语言和系统并不是真的足够强大到能构建复杂的大型软件，大型系统必须被设计用以重用组件。因此，一种融合的传统应运而生。

那“正确的做法”的表现如何呢？有两种基本场景：“复杂的大型系统”场景和“钻石类的珠宝”场景。

“复杂的大型系统“场景通常像这样：

首先，”正确的做法“需要设计。然后它的实现需要设计。最后，进行实现。因为这是”正确的做法“，它拥有几乎100%的所需功能， 实现简单性从来都不是一个问题，因此需要很长时间才能实现。 它巨大而且复杂。正确使用需要复杂的工具。 最后 的20%花费了80%的精力，因此“正确的做法”需要很长的时间来完成，并且它只有在最高级的硬件上才能运行得令人满意。

“钻石类的珠宝“场景通常表现如下：

“正确的做法”要花大量的时间去设计，但在整个过程中的每一点都是很小的。要将它实现得运行快速，要么是不可能的，要么就超出了大多数实现者的能力。

这两种场景对应于通用Lisp和Scheme。

第一个场景也是典型人工智能软件的场景。 

“正确的做法”通常是一个大型软件，但除了“正确的做法”会把软件设计得巨大外，没有其它的理由造成这种局面。也就是说，这个特征是一种偶然情况。

从中吸取的教训是，先去做正确的事情往往是不可取的。最好采纳“正确的做法”的一半，让软件能像病毒一样扩散。一旦人们被它吸引，花时间去改进它，使它接近90%的“正确的做法”。

一个错误的教训是从字面上理解这个寓言，并得出结论：C语言是人工智能软件的合适载体。 50%的解决方案必须是基本正确的，而在这种情况下并非如此。 

但是，有一点我们可以下结论，Lisp社区真的需要认真的反省一下他们在Lisp设计上的立场。后面，我会讨论更多的相关问题……