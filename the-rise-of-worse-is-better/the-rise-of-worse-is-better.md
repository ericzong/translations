**“更糟糕的更好”设计理念的兴起**

​	Richard P. Gabriel

​		Lucid, Inc

> 英文原文：[The Rise of Worse is Better](http://dreamsongs.com/RiseOfWorseIsBetter.html)
>
> 翻译参考：http://blog.sina.com.cn/s/blog_66d65c7d0100sw82.html

{从["Lisp: Good News, Bad News, How to Win Big."](http://dreamsongs.com/WIB.html)摘录}



**2.1 “更糟糕的更好”设计理念的兴起**

我和Common Lisp和CLOS(Common Lisp Object System)的几乎每一位设计师都对麻省理工学院/斯坦福大学(MIT/Stanford)的设计风格极度了解（extreme exposure）。这种风格的精髓可以从“正确的做法(the right thing)”这个短语中捕捉到。对于这样的设计师，重要的是彻底搞清楚下列所有特性：

* 简单性——设计必须简单，无论是在实现上还是在接口上。接口的简单要比实现的简单更加重要。
* 正确性——设计必须在所有可观察的方面都是正确的。不正确是绝对不允许的。
* 一致性——设计必须保持一致兼容。为了避免不一致，设计上允许略微不那么简单完整。一致性和正确性同等重要。
* 完整性——设计必须涵盖尽可能多的重要情况，这是切实可行的。所有合理预期的情况都必须涵盖到。简单性不能过度的损害完整性。

我相信大多数人都会同意，这都是一些好的特性。我把这种设计理念的运用称为“麻省理工方法(MIT approach)”。Common Lisp(包括CLOS)和Scheme代表着麻省理工方法的设计和实现。

“更糟糕的更好(Worse is Better)”的理念只是稍微有点不同：

* 简单性——设计必须简单，无论是在实现上还是在接口上。实现的简单要比接口的简单更加重要。设计中，简单性是最重要的考量。
* 正确性——设计必须在所有可观察的方面都是正确的。为了简单性，正确性可以做轻微的让步。
* 一致性——设计不能过度不一致。为了简单，一致性可以在某些方面做些牺牲，但与其引入实现复杂性和不一致性，不如删除设计中处理不太普遍情况的那些部分。
* 完整性——设计必须涵盖尽可能多的重要情况，这是切实可行的。所有合理预期的情况都必须涵盖到。在有利于任何其它（特性的）品质的情况下，完整性可以牺牲。事实上，当实现的简单性受到损害时，就必须牺牲完整性。如果保有简单性，可以牺牲一致性来实现完整性；尤为无用的是接口的一致性。

早期的Unix和C语言是使用这种设计学派的例子，我把这种设计策略的运用称为“新泽西方法(New Jersey approach)”。我故意讽刺“更糟糕的更好”的理念，让你相信它显然是一种不好的理念，而新泽西方法是一种不好的（软件实现）方法。

然而，即使在这种假象（strawman form）下，我相信“更糟糕的更好”理念也要比“正确的做法”理念有更大的生存空间，并且对于软件而言，新泽西方法要比麻省理工方法更实用。

让我来复述一个故事，它表明麻省理工方法和新泽西方法之间的差别是存在（valid）的，以及各个理念的支持者实际上都相信他们的理念更好。

两位著名的人物，一位是来自麻省理工，另一位来自伯克利学院(但是正在研究Unix)，曾见面一起讨论操作系统问题。来自麻省理工的人对 ITS（麻省理工学院人工智能实验室的操作系统）非常熟悉，并一直在阅读Unix的源代码。他对Unix如何解决PC loser-ing问题感兴趣。 当用户程序调用系统例程以执行可能具有重要状态(如IO缓冲区)的长时间操作时，就会出现PC失败问题。如果在操作期间发生中断，则必须保存用户程序的状态。由于系统例程的调用通常是一条指令，用户程序的PC程序不能充分捕获进程的状态。系统例程要么退出（back out），要么强行继续运行（press forward）。“正确的做法”是退出，并将用户程序PC恢复到调用系统例程的指令，以便在中断后恢复用户程序，例如，重新进入系统例程。这被称为“PC loser-ing”，因为PC机被强迫进入“loser模式”，这里，“loser”是麻省理工对“用户”的一种爱称（the affectionate name）。

这个麻省理工的人没有看到有任何的用来处理这种情况的代码，于是问那个新泽西人，这种问题是如何处理的。新泽西人说，Unix的人意识到了这个问题，但解决方案是针对系统例程通常能正常完成的情况的，但有时会返回错误代码，这表明系统例程没有完成它的操作。然后，一个正确的用户程序需要检查错误码来决定是否简单地重试该系统例程。麻省理工的人不喜欢这个解决方案，因为这不是“正确的做法”。

新泽西人说，Unix的解决方案是正确的，因为Unix的设计理念是追求简单性，而“正确的做法”太复杂。此外，程序员可以容易地插入额外的测试和循环。麻省理工的人指出，这种实现确实简单，但接口的功能是复杂的。新泽西人指出，Unix选择了正确的折衷方案——即实现简单性比接口简单性更重要。

麻省理工的人喃喃地说：有时严谨决定一切，但新泽西人不明白（我不确定是否我也不明白）。

现在，我想说“更糟糕的更好”确实是更好。C语言是一种为开发Unix而设计的程序语言，它是使用新泽西方法设计的。C语言因此是一种很容易就能写出像样的编译器的语言，它要求程序员编写易于编译器解释的文本。有些人称C语言为高级（fancy）汇编语言。早期的Unix和C编译器都具有简单的结构，易于移植，运行所需的硬件资源很少，并且提供了你想从一个操作系统和编程语言里得到50%-80%的功能。

在任何时刻存在的计算机一半都比中值差(较小或更慢)。Unix和C语言在它们上面运行良好。“更糟糕的更好”理念表明，实现的简单性具有最高的优先级，这意味着Unix和C语言很容易在这些机器上进行移植。因此，一种预期是，如果Unix和C语言支持的50%的功能令人满意，那它们将开始出现在任何地方。对吧，不是吗？

Unix和C语言是终极电脑病毒。

“更糟糕的更好”理念另外一个好处是，程序员习惯于牺牲一些安全、方便和分歧（hassle），以获得良好的性能和适度的资源使用。使用新泽西方法编写的程序在小型和大型机器上都能很好地工作，而且代码将是可移植的，因为它是在病毒的基础上编写的。





有一点很重要，初始病毒必须基本上好用。病毒的传播由于它的可迁移性而得到保证。一旦病毒传播开来，迎来的压力会促使它进一步改进，促使增加功能至 接近90%完备的水平，但用户此时已经有条件的习惯了这种比“正确的做法”差一点的东西了。所以，“更糟糕的更好”的软件会首先获得人们的接受，然后会有限 制的让用户降低期望，最后进行改进，直至接近“正确的做法”。在实际情况中，1987年的Lisp编译器当时和C编译器都是非常的优秀，但是很多的编译器 专家仍然努力让C编译器做的更好。

1995年的好消息是我们有了一个好的操作系统和编程语言；而坏消息是它们分别是Unix和C++。

“更糟糕的更好”还有最后一个好处。因为新泽西式的语言和系统不够真正的强大来开发出复杂巨型的软件，大型系统必须在设计上进行组件重用。因此，一种整合的传统就此迅速出现了。

那“正确的做法”的表现如何呢？我们有两种常见的模式：“复杂的大型系统”模式和“钻石类珍宝“模式。

“复杂的大型系统“模式通常像这样：

首先，”正确的做法“需要去设计。然后实现过程需要去设计。最后，进行实现。因为这是”正确的做法“，它会提供100%预期的功能，实现的简单性从 来不是一个可考虑的因素，所以你要用很长的时间去完成它。它巨大而且复杂。它需要复杂的工具，工具需要能正确的使用。其中20%的功能会花去你80%的精 力，所以，”正确的做法“需要很长的时间来完成，它的运行只有在采用先进技术的硬件上才会表现的令人满意。

“钻石类珍宝“模式通常表现如下：

”正确的做法“花了大量的时间去设计，但这种方式，在单个功能点上，其实并没有占多大比重。这种设计的实现，如果想让它运行的快，要么是根本不可能，要么是超出了大多数开发者的能力。

头一种模式也是经典的人工智能软件的开发模式。

”正确的做法“出来的通常是大型的软件，但除了”正确的做法“会把软件设计的巨大外，没有其它的理由造成这种局面。也就是说，大型软件里很多功能是偶然会用到的。

从这些事情中我们学到的知识是，人们通常不喜欢按照”正确的做法“做事。但你最好要采纳一半的”正确的做法“，让你的软件能像病毒一样流传。一旦人们被它吸引，花时间去改进它，使它接近90%的”正确的做法“。

一个错误的认识是只理解表面意思，认为C语言是开发AI软件有力的武器。50%正确做法的方案平常是可行的，但AI上不行。

但是，有一点我们可以下结论，Lisp社区真的需要认真的反省一下他们在Lisp设计上的立场。我会在以后更多的谈论这个问题。